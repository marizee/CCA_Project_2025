\documentclass[a4paper]{article}
\input{preamble}

\begin{document}

\thispagestyle{plain}
\begin{titlepage}
    \begin{figure}[h]
        \centering
        \includegraphics[width=0.4\textwidth]{su.png}
    \end{figure}
    \vspace{1cm}

    \begin{center}
        {\LARGE PCCA}\\[0.3cm]
        \rule{\linewidth}{0.5mm} \\[0.4cm]
        {\huge \textbf{Modular arithmetic and vectorization using\\ SIMD and AVX}}\\[0.4cm]
        \rule{\linewidth}{0.5mm} \\[1cm]
        {\large 24 January 2025 - 20 May 2025}\\[3cm]

        {\Large Damien ASSIRE \& Marie BONBOIRE}


    \end{center}

    \vfill
\begin{flushleft}{\large
    \textbf{Supervisor:} Mr. Vincent NEIGER\footnote{\url{https://vincent.neiger.science/}} (LIP6 - PolSys)\\
    }
\end{flushleft}
\end{titlepage}
\newpage

\tableofcontents
\newpage

\paragraph{NOTATIONS:} (to be removed from report, just for consistency)
\begin{itemize}
    \item $B$ the max bitsize, either $32$ or $64$,
    \item $n$ the modulus,
    \item $N$ the size of a vector,
    \item $a,b$ vectors, coefficients are $a_i$, $b_i$,
    \item $x,y$ for integers,
    \item $p_{hi}, p_{lo}$ temp variables,
    \item $p$ prime number,
    \item todo: Choose between writting high, middle and low part as $\{hi,mi,lo\}$ or $\{high, middle, low\}$ but not both,
\end{itemize}

\newpage
\section{Preface}

\subsection{Goals}
\begin{itemize}
    \item Implement basic arithmetic operations (scalar-vector multiplication, vector-vector multiplication, dot product) using library FLINT.
    \item Study the impact of the modulo operation.
    \item Enhance these operations using Intel's intrinsics for Single Instruction Multiple Datas (SIMD) vectorization.
    \item Advanced benchmarking/profiling.
    \item Apply on a form of butterfly FFT for a forward integration to FLINT.
\end{itemize}

\subsection{Machines description}


% 2023 - 4.5 GHz % mariz
% 2019 - 2.5 GHz % ppti
% 2023 - 3.3 GHz % argiope
% 2021 - 3.0 GHz % groebner

\begin{tikzpicture}[very thick, black]

    %coordinates
    \coordinate (O) at (1,0); % Origin
    \coordinate (F) at (12,0); %End
    \coordinate (P1) at (2,0); %ppti
    \coordinate (P2) at (6.5,0); %groebner
    \coordinate (P3) at (11,0); %mariz+argiope

    %proc
    \draw[<-,thick,color=black] ($(P1)+(0,0.2)$) -- ($(P1)+(0,1.5)$) node [above=0pt,align=center,black] 
    {Intel® xeon® Gold 6248 Processor \\ (Cascade Lake, AVx512) \\ 2.5 GHz};
    \draw[<-,thick,color=black] ($(P2)+(0,0.2)$) -- ($(P2)+(0,0.7)$) node [above=0pt,align=center,black] 
    {Intel(R) xeon(R) Gold 6354 \\ (IceLake, AVx512) \\ 3.0 GHz};
    \draw[<-,thick,color=black] ($(P3)+(0,0.2)$) -- ($(P3)+(0,1.5)$) node [above=0pt,align=center,black] 
    {AMD Ryzen 7 PRO 7840U \\ (Zen 4, AVx512) \\ 3.3 GHz};
    \draw[<-,thick,color=gray] ($(P3)-(0,0.6)$) -- ($(P3)-(0,1.5)$) node [below=0pt,align=center,gray] 
    {Intel(R) Core(TM) Ultra 5 125H \\ (Meteor Lake) \\ 4.5 GHz};

    %main arrow
    \draw[->] (O) -- (F);

    %ticks
    \foreach \x in {2,6.5,11}
    \draw(\x cm,3pt) -- (\x cm,-3pt);
    %labels
    \foreach \i \j in {2/2019,6.5/2021,11/2023}{
    	\draw (\i,0) node[below=3pt] {\j} ;
    }

\end{tikzpicture}

\section{SIMD instructions}

\begin{itemize}
    \item Intel intrinsics guide\footnote{\url{https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html}}
    \item avx2: 256 bits registers \texttt{\_\_m256i} \verb+-->+ vectors of 4 integers
    \item avx512: 512 bits registers \texttt{\_\_m512i} \verb+-->+ vectors of 8 integers
    \item general description cf. slides PPAR
\end{itemize}


\section{Multiplication of 64 bits integers}

When multiplying two integers, a problem of overflow can arise since the result might be too big to be stored in a 64 bits word. 
To circumvent this issue, one needs to first split the two integers into two words of a given size and then apply the long multiplication.

\subsection{Long multiplication}
Given two integers $x,y$ both of at most 64 bits, we start by splitting them into 2 words, one of $k$ bits and the other one of at most $64-k$
bits, with $k<64$:

\begin{align*}
    x &= x_{hi}\cdot 2^{k} + x_{lo} \\
    y &= y_{hi}\cdot 2^{k} + y_{lo}.
\end{align*}

The long multiplication consists in computing the multiplication of 64 bits limbs using multiplications and additions of
integers with a lower size.

We compute
\begin{align*}
    r_{lo} &= x_{lo}\cdot y_{lo} \\
    r_{mi} &= x_{lo}\cdot y_{hi} + x_{hi}\cdot y_{lo} \\
    r_{hi} &= x_{hi}\cdot y_{hi}
\end{align*}
then $ab = r_{lo} + (r_{mi} \ll k) + (r_{hi} \ll 2k)$.

\textcolor{orange}{This is maybe not detailed enough concerning overflows. For
  example:
\begin{itemize}
  \item if \(k\) is not \(32\), then some of these four products will again
    not fit in 64 bits
  \item if \(x\) and \(y\) are really up to \(64\) bits, then there may be an overflow
    in the addition for \(r_{mi}\) (you can say that for practical reasons we will restrict
    to 62 or 63 bits)
  \item the formula for \(ab\) is mathematically correct, but make it clear
    that this is ``only mathematical'' (i.e.\ this does not fit in a 64 bit word)
\end{itemize}}

\subsection{Retrieve the high and the low part of the result}

Since the product $xy$ can have more than 64 bits, but always has at most 128 bits, the output of this operation is usually given as a pair of words of at most 64 
bits such that $xy = (xy)_{hi}\cdot 2^{64} + (xy)_{lo}$.

\begin{itemize}
    \item Flint's function \texttt{umulppmm}
    \item avx2: no mullo/mulhi (mullo only up to epu32; mulhi only up to epu16)
    \item avx512: mullo (epi64) but no mulhi; and mullo rather slow until very recently (give some throughput values for mullo-epi64 for the processors you consider in the report)
\end{itemize} 

\section{Classic arithmetic operations on vectors}

\subsection{Addition of two vectors}

\begin{itemize}
    \item not done atm but todo 
    \item modular reduction might be delayed
      (maybe delayed reduction could be stated as a general principle,
      to circumvent the high cost of reductions;
      it will be possible for some operations but not for others)
\end{itemize}

\subsection{Multiplication of a vector by a scalar or by another vector}

\begin{itemize}
    \item define the operations.
    \item boils down to mult described above
    \item (here, delaying reductions is basically not possible)
\end{itemize}

\subsection{Dot product}

For two vectors $u$ and $v$ of $len$ integers of bit size $bitsize \le 32$, and an integer $n$ of some bit size, we want to compute

\[\left(\sum_{i=0}^{len}u_iv_i\right) \mod n\]

To compute the sum of products, we split the integers as described in subsection \ref{sub:split}. Then, we sum separately the three limbs $r_{high}$, $r_{mid}$, $r_{low}$. % TODO: Verify name

(Here, this is a perfect problem for delaying reductions: e.g. if \(n < 2^{30}\), then a product \(u_iv_i\) is \(< 2^{60}\), so we can sum up to \(2^4 = 16\) terms before doing a reduction)

\subsubsection{Modular reduction}

The modular is done with \texttt{NMOD2\_RED2} from the flint library. We first regroup the three limbs in two limbs $h$ and $l$ as follows:

\begin{align}
    l &= r_{mid}B &+ \left(r_{high}B^2 + r_{low}\right) \\
    h &= \left\lfloor r_{mid}\frac{B}{2^{64}}\right\rfloor &+ \left\lfloor r_{hi}\frac{B^2}{2^{64}}\right\rfloor &+ c \quad{\text{where $c$ is $1$ if the computation of l overflows and 0 otherwise}}
\end{align}

Because of the cost of this operation, we only reduce at the end, adter the sum. As a consequence, the number of integers we can sum without overflows is limited, and depend of their size.

\begin{proposition}\label{prop:sum}
    For integers of size $\S$, the result of the sum of $2^n$ of such integers is at most $S + n$
\end{proposition}

\begin{proof}
    By induction on $n\in\mathbf{N}$

    \paragraph{Base case: $n = 0$}
    $2^0 = 1$, thus no addition is done and the result has size $S = S + 0 = S + n$. Hence, $\Pi(0)$ is verified.

    \paragraph{Induction}
    Assume for some $i \in \mathbf{N}^*$, $\Pi(i - 1)$ is verified.

    Let $u$ and $v$ be the sums of $2^{i-1}$ integers of size $ S $. By $\Pi(i-1)$, their sizes are at most $S + i - 1$. So the size of $u + v$ is at most $\left(S + i + 1\right) + 1 = S + i$, and $u + v$ is the sum of $2 \cdot 2^(i-1) = 2^i$ integers.
    So $\Pi(i)$ is verified, hence $\Pi(i-1) \Rightarrow \Pi(i)$

    \paragraph{By induction's principle:} $\Pi(0)$ is verified and $\forall i\in\mathbf{N},\ \Pi(i) \Rightarrow \Pi(i+1)$, So
    \begin{displaymath}
        \forall n\in\mathbf{N},\ \Pi(n)\text{ is verified}
    \end{displaymath}
\end{proof}

This value can be computed using \ref{prop:sum}. In our case, because we sum the results of the products of two integers of bit size $bitsize,\ S = 2 bitsize$.

TODO: Max for rhi, rmi and rlo



\section{Butterfly Fast Fourier Transform}

The butterfly refers to an operation that takes place in Cooley-Tukey algorithm (todo:ref), a common algorithm to perfom 
Fast Fourier Transform (FFT), which takes as inputs: $n, w$ a modulus and a scalar of at most 64 bits, and two integers 
$x, y$ in $\mathbb{Z}_n$, and performs the in-place computation:
\[
(x,y) \mapsto (x + w\cdot y \mod n,\ x - w\cdot y \mod n).
\]

Our goal is to study the methods used to efficiently implement this operation on vectors with coefficients in $\mathbb{Z}_n$.

(Looking at the more global picture, in the FFT algorithm such a butterfly will
be applied to a long vector of different \(x_i, y_i\) but with the same \(w\) and \(n\).
Hence the motivation to perform some precomputations on \(w\) and \(n\) that will speed
up subsequent multiplications by \(w\) mod \(n\))

\subsection{Multiplication with precomputation}

The butterfly described above leads to the computation of several modular multiplications where one operand and the modulus are fixed.
To take the most of these fixed parameters, V. Shoup (todo:ref) introduced a step of precomputation that allows to speed up the modular reduction.
%% for the ref, you can find some ideas in Flint's documentation for n_mulmod_shoup

Let $B$ be the maximum bitsize of a word ($B\in \{32, 64\}$). Given $n$ and $w \in \mathbb{Z}_n$, one can compute a scaled approximation 
of $\frac{w}{n}$, which is precisely $$ w_{pre} = \biggl\lfloor\dfrac{w\cdot 2^{B}}{n} \biggr\rfloor.$$

Then, for a given vector $b = (b_1,\dots, b_N)$ , one can compute $(wb_i \mod n)$ for all $i\in{1,\dots, N}$ as follows:

\begin{enumerate}
    \item Find $p_{hi}, p_{lo}$ such that $w_{pre} \cdot b_i = p_{hi}\cdot 2^B + p_{lo}$,
    \item Compute $c = wb_i - p_{hi}n$,
    \item If $c \leq n$, return $c-n$, else return $c$.
\end{enumerate}

The correctness of this algorithm relies on the definition of $w_{pre}$. 

\begin{proposition}\label{prop:quorem}
For $(x,y) \in \mathbb{Z}\times \mathbb{N}^*$, the quantities $q=\left\lfloor\frac{x}{y}\right\rfloor$ and 
$r=x - \left\lfloor\frac{x}{y}\right\rfloor y$ are respectively the quotient and the remainder in the Euclidian division of $x$ by $y$.
\end{proposition}
    
\begin{proof}
From the definition of the floor of a rational number, we have:
\[
    \left\lfloor\dfrac{x}{y}\right\rfloor \leq \dfrac{x}{y} < \left\lfloor\dfrac{x}{y}\right\rfloor + 1 \Longleftrightarrow
    \left\lfloor\dfrac{x}{y}\right\rfloor y \leq x < \left\lfloor\dfrac{x}{y}\right\rfloor y + y \Longleftrightarrow
    0 \leq x - \left\lfloor\dfrac{x}{y}\right\rfloor y < y.
\]
We then consider $q=\left\lfloor\dfrac{x}{y}\right\rfloor$ and by the uniqueness of the quotient in the Euclidian division with remainder, 
it implies that $x = yq + r$ with $r=x - \left\lfloor\dfrac{x}{y}\right\rfloor y$ and $0 \leq r < y$.
\end{proof}

\begin{proof} (Correctness of the algorithm)
First, using \autoref{prop:quorem}, we have that $w_{pre}= \left\lfloor\frac{w\cdot 2^B}{n}\right\rfloor $ is the quotient in the division 
of $w\cdot 2^B$ by $n$. Thus,
\[
    w\cdot 2^B = w_{pre}\cdot n + r \text{ with } 0 \leq r < n\ \Longleftrightarrow\ w_{pre} = \dfrac{w\cdot 2^B - r}{n}
\]

Thus, by definition of $p_{hi}$,
\[
p_{hi} = \left\lfloor\frac{w_{pre}\cdot b_i}{2^B}\right\rfloor
= \left\lfloor\dfrac{wb_i}{n} - \dfrac{rb_i}{n\cdot 2^B} \right\rfloor.
\]

From the requirements on $r$ and $b_i$ and the previous result, we have that
\[
\left\lfloor\dfrac{wb_i}{n}\right\rfloor - 1 \leq p_{hi} \leq \left\lfloor\dfrac{wb_i}{n}\right\rfloor
\]
and this means that $p_{hi}$ is either $\left\lfloor\frac{wb_i}{n}\right\rfloor - 1$ or $\left\lfloor\frac{wb_i}{n}\right\rfloor$.


It follows that we have
\begin{align*}
\text{either } &c=w\cdot b_i - \left\lfloor\frac{wb_i}{n}\right\rfloor n + n \\
\text{or } &c=w\cdot b_i - \left\lfloor\frac{wb_i}{n}\right\rfloor n.
\end{align*}
Using \autoref{prop:quorem} again, we have $c=wb_i \mod n$ or $c=(wb_i \mod n)+n$, and the last step of the algorithm ensures 
that we retrieve $wb_i \mod n$.
\end{proof}

\subsection{Harvey's lazy butterfly fft}

\begin{itemize}
    \item restrict the size of the inputs such that the output can be stored in a 64 bits word.
    \item describe theses restrictions.
\end{itemize}


\section{Modular reduction with special primes}

\subsection{Mersenne primes}

%$p = 2^u - 1$
%\[
%p \mod p \Longleftrightarrow 2^u - 1 = 0 \mod p \Longleftrightarrow 1^u = 1 \mod p
%\]
%------> with $ab = ab_{hi}\cdot 2^{64} + ab_{lo}$, it means that if we take the Mersenne's prime number $p = 2^{64} - 1$, 
%we can compute $ab \mod p$ with only one addition 
%\[
%    ab \mod p \Longleftrightarrow ab_{hi}\ + ab_{lo} \mod p
%\]

\subsection{Generalized Mersenne primes}


\section{Profiling/Benchmarking}



\subsection{Verification of timings}

\subsection{Impact of caches} % todo Draft

In the benchmarks, we observes bigger factors than expected between two sizes,
e.g. during the unrolling of non modular dot product. This happen when a vector
become too big to fit in a certain cache, and must be stored in a lower level
cache or in the primary memory. In the previously cited case, it happen for sizes
65536 and 131072 on ppti-gpu-4. % todo detail of calculation


\subsection{Results}

\section{Conclusion}



\newpage
\bibliographystyle{plain} 
\bibliography{biblio} 
\nocite{*}

\end{document}
